<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>終極井字遊戲</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        #gameContainer {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3x3 for big squares */
            gap: 15px; /* Gap between big squares */
            padding: 15px;
            border: 2px solid #333;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .big-square {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3x3 for small cells */
            gap: 5px; /* Gap between small cells */
            border: 2px solid #aaa;
            position: relative; /* For winner overlay */
            background-color: #eee;
            padding: 5px;
        }

        .cell {
            width: 50px; /* Small cell size */
            height: 50px;
            font-size: 2em;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #fff;
            border: 1px solid #ccc;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .cell:hover:not(:disabled) {
            background-color: #e0e0e0;
            transform: scale(1.05);
        }

        .cell:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Player X and O styles */
        .cell-x { color: #e74c3c; } /* Red for X */
        .cell-o { color: #3498db; } /* Blue for O */

        /* Big square winner overlay */
        .big-square.won-x::before,
        .big-square.won-o::before,
        .big-square.tie::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 5em; /* Large size for winner symbol */
            font-weight: bold;
            color: rgba(0, 0, 0, 0.3); /* Semi-transparent */
            z-index: 10;
        }
        .big-square.won-x::before { content: 'X'; color: rgba(231, 76, 60, 0.3); }
        .big-square.won-o::before { content: 'O'; color: rgba(52, 152, 219, 0.3); }
        .big-square.tie::before { content: 'T'; color: rgba(100, 100, 100, 0.3); }

        /* Highlight for active big square */
        .big-square.active-square {
            border-color: #2ecc71; /* Green highlight */
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.6);
        }

        #info-panel {
            margin-top: 20px;
            text-align: center;
            font-size: 1.2em;
        }

        #currentPlayerDisplay {
            font-weight: bold;
            color: #333;
        }

        #gameMessage {
            color: #e74c3c;
            margin-top: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>終極井字遊戲</h1>
    <div id="info-panel">
        <div id="currentPlayerDisplay">當前玩家: </div>
        <div id="gameMessage"></div>
    </div>

    <div id="gameContainer">
        <script>
            for (let major = 0; major < 9; major++) {
                document.write(`<div class="big-square" data-big-idx="${major}">`);
                // Loop for 9 small cells inside each big square
                for (let minor = 0; minor < 9; minor++) {
                    document.write(`<button class="cell" data-major-idx="${major}" data-minor-idx="${minor}"></button>`);
                }
                document.write(`</div>`);
            }
        </script>
    </div>

    <script>
        const BACKEND_BASE_URL = 'https://tic-119788516387.asia-east1.run.app'; // 這一行是新的！
        let gameState = {}; // Global game state
        let gameState = {}; // Global game state
        async function fetchGameStatus() {
            try {
                // console.log('Fetching game status...'); // Debug log
                const res = await fetch(`${BACKEND_BASE_URL}/game/status`);
                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`無法取得遊戲狀態: ${res.status} ${res.statusText} - ${errorText}`);
                }
                gameState = await res.json();
                // console.log('Game state received:', gameState); // Debug log
                updateUI();
            } catch (err) {
                console.error('取得遊戲狀態失敗:', err);
                const msgDiv = document.getElementById('gameMessage');
                if (msgDiv) {
                    msgDiv.textContent = `後端連線失敗或錯誤: ${err.message || err}。請檢查後端是否運行。`;
                }
            }
        }

        async function sendMove(majorIdx, minorIdx) {
            if (!gameState || !gameState.player) {
                document.getElementById('gameMessage').textContent = '遊戲狀態未初始化，無法下棋。';
                return;
            }

            // Client-side validation (basic, backend does full validation)
            const nextSquare = gameState.next_square;
            const bigStatus = gameState.big_squares?.[majorIdx];
            const cellValue = gameState.board?.[majorIdx]?.[minorIdx]; // Accessing board like a 2D array
            
            // Check if game is already over
            if (gameState.message && gameState.message.includes('遊戲結束')) {
                document.getElementById('gameMessage').textContent = gameState.message;
                return;
            }

            // If a specific big square must be played in, and it's not this one
            if (nextSquare !== -1 && majorIdx !== nextSquare) {
                document.getElementById('gameMessage').textContent = `請在指定的大格 (索引 ${nextSquare}) 下棋！`;
                return;
            }

            // If the big square is already won/tied
            if (bigStatus && bigStatus !== ' ') {
                 // Check if next_square is -1 (free choice) and this big square is won/tied
                if (nextSquare === -1) {
                    // Allow playing in *any* open big square if next_square is -1
                    if (bigStatus !== ' ') { // If this chosen big square is won/tied, you can't play there
                        document.getElementById('gameMessage').textContent = `這個大格子 (索引 ${majorIdx}) 已經結束了，請選擇其他可用的格子。`;
                        return;
                    }
                } else { // next_square is specific, but that square is won/tied
                    document.getElementById('gameMessage').textContent = `指定的大格子 (索引 ${nextSquare}) 已經結束了，您現在可以在任何未結束的大格子下棋。`;
                    // When the "next_square" itself is won/tied, the backend should set next_square to -1
                    // So this client-side check might not be fully accurate. Backend is authoritative.
                    // For now, let's allow it to pass to backend to get official message
                    // if this scenario (next_square is won but we clicked it) is handled by backend.
                }
            }

            // If the small cell is already occupied
            if (cellValue && cellValue !== ' ') {
                document.getElementById('gameMessage').textContent = '這個小格子已被佔據，請選擇其他格子。';
                return;
            }

            try {
                // console.log(`Sending move: major=${majorIdx}, minor=${minorIdx}, player=${gameState.player}`); // Debug log
                const res = await fetch(`${BACKEND_BASE_URL}/game/move`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        major_idx: majorIdx,
                        minor_idx: minorIdx,
                        player: gameState.player
                    })
                });

                if (!res.ok) {
                    const errorData = await res.json();
                    throw new Error(errorData.detail || '移動失敗');
                }
                const responseData = await res.json();
                // console.log('Move response:', responseData); // Debug log
                // Update gameState directly from response if needed, or re-fetch.
                // For simplicity, let's re-fetch the status after a successful move.
                fetchGameStatus(); // Re-fetch to update UI based on new server state
                const msgDiv = document.getElementById('gameMessage');
                if (msgDiv && responseData.message) {
                     msgDiv.textContent = responseData.message; // Display message from backend
                }
            } catch (err) {
                console.error('送出移動失敗:', err);
                const msgDiv = document.getElementById('gameMessage');
                if (msgDiv) {
                    msgDiv.textContent = `移動失敗: ${err.message || err}。`;
                }
            }
        }

        function updateUI() {
            if (!gameState.board || !gameState.big_squares) {
                console.warn('Game state is incomplete, cannot update UI.');
                return;
            }

            // Update small cells
            for (let major = 0; major < 9; major++) {
                for (let minor = 0; minor < 9; minor++) {
                    const cellValue = gameState.board[major][minor] || ' '; // Access as 2D array
                    const cell = document.querySelector(`.cell[data-major-idx="${major}"][data-minor-idx="${minor}"]`);
                    
                    if (cell) {
                        cell.textContent = cellValue === ' ' ? '' : cellValue;
                        cell.classList.remove('cell-x', 'cell-o');
                        if (cellValue === 'X') cell.classList.add('cell-x');
                        if (cellValue === 'O') cell.classList.add('cell-o');
                        
                        // Disable cell if occupied or if the big square is won/tied
                        const bigSquareStatus = gameState.big_squares[major];
                        if (cellValue !== ' ' || bigSquareStatus !== ' ') {
                            cell.disabled = true;
                        } else {
                            cell.disabled = false; // Re-enable if clear
                        }
                    }
                }
            }

            // Update big squares status (won/tie) and remove active highlight
            for (let bigIdx = 0; bigIdx < 9; bigIdx++) {
                const bigStatus = gameState.big_squares[bigIdx] || ' ';
                const bigContainer = document.querySelector(`.big-square[data-big-idx="${bigIdx}"]`);
                if (bigContainer) {
                    bigContainer.classList.remove('won-x', 'won-o', 'tie', 'active-square'); // Remove all before re-applying
                    if (bigStatus === 'X') bigContainer.classList.add('won-x');
                    if (bigStatus === 'O') bigContainer.classList.add('won-o');
                    if (bigStatus === 'T') bigContainer.classList.add('tie');
                }
            }

            // Apply highlight for next playable big square(s)
            const nextSquare = gameState.next_square;
            const isGameOver = gameState.message && gameState.message.includes('遊戲結束'); // Check if backend sent game over message

            if (!isGameOver) {
                for (let bigIdx = 0; bigIdx < 9; bigIdx++) {
                    const bigContainer = document.querySelector(`.big-square[data-big-idx="${bigIdx}"]`);
                    const bigSquareStatus = gameState.big_squares[bigIdx];

                    if (bigContainer && bigSquareStatus === ' ') { // Only highlight if not already won/tied
                        if (nextSquare === -1) {
                            // Any un-won/un-tied big square is active
                            bigContainer.classList.add('active-square');
                        } else if (bigIdx === nextSquare) {
                            // Only the specified big square is active
                            bigContainer.classList.add('active-square');
                        }
                    }
                }
            }


            // Display current player
            const playerDisplay = document.getElementById('currentPlayerDisplay');
            if (playerDisplay) {
                playerDisplay.textContent = `當前玩家: ${gameState.player || '載入中...'}`;
                if (isGameOver) {
                     playerDisplay.textContent = `遊戲已結束`;
                }
            }

            // Display game messages
            const msgDiv = document.getElementById('gameMessage');
            if (msgDiv) {
                if (isGameOver) {
                    msgDiv.textContent = gameState.message;
                    disableBoard();
                } else if (gameState.message && gameState.message !== "移動成功！") { // Display temporary messages from backend
                    msgDiv.textContent = gameState.message;
                } else {
                    msgDiv.textContent = ''; // Clear message if it's just "移動成功" or no specific message
                }
            }
        }

        function disableBoard() {
            const cells = document.querySelectorAll('.cell'); // Select all cells
            cells.forEach(cell => cell.disabled = true);
        }

        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Add click event listeners to all cells
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.addEventListener('click', () => {
                    const majorIdx = Number(cell.dataset.majorIdx);
                    const minorIdx = Number(cell.dataset.minorIdx);
                    // console.log(`Cell clicked: Major=${majorIdx}, Minor=${minorIdx}`); // Debug log
                    sendMove(majorIdx, minorIdx);
                });
            });
            fetchGameStatus(); // Fetch initial game status
        });
    </script>
</body>
</html>